# Generated by Qodo Gen
import os

import pytest

from api_client.helpers.general import write_string_2file


class TestWriteString2file:

    # Successfully writes a string to a file in write mode
    def test_write_string_to_file_in_write_mode(self):
        # Arrange
        test_file = "test_write.txt"
        test_content = "Hello, World!"

        # Act
        write_string_2file(test_file, test_content)

        # Assert
        with open(test_file, "r", encoding="utf-8") as file:
            content = file.read()
        assert content == test_content

        # Cleanup
        os.remove(test_file)

    # Successfully writes a string to a file in append mode
    def test_write_string_to_file_in_append_mode(self):
        # Arrange
        test_file = "test_append.txt"
        initial_content = "Initial content\n"
        append_content = "Appended content"

        # Create file with initial content
        with open(test_file, "w", encoding="utf-8") as file:
            file.write(initial_content)

        # Act
        write_string_2file(test_file, append_content, mode="a")

        # Assert
        with open(test_file, "r", encoding="utf-8") as file:
            content = file.read()
        assert content == initial_content + append_content

        # Cleanup
        os.remove(test_file)

    # Creates a new file if it doesn't exist
    def test_creates_new_file_if_not_exists(self):
        # Arrange
        test_file = "new_test_file.txt"
        test_content = "Content in new file"

        # Ensure file doesn't exist
        if os.path.exists(test_file):
            os.remove(test_file)

        # Act
        write_string_2file(test_file, test_content)

        # Assert
        assert os.path.exists(test_file)
        with open(test_file, "r", encoding="utf-8") as file:
            content = file.read()
        assert content == test_content

        # Cleanup
        os.remove(test_file)

    # Overwrites existing file content when using write mode
    def test_overwrites_existing_content_in_write_mode(self):
        # Arrange
        test_file = "test_overwrite.txt"
        initial_content = "Initial content that should be overwritten"
        new_content = "New content"

        # Create file with initial content
        with open(test_file, "w", encoding="utf-8") as file:
            file.write(initial_content)

        # Act
        write_string_2file(test_file, new_content)

        # Assert
        with open(test_file, "r", encoding="utf-8") as file:
            content = file.read()
        assert content == new_content
        assert content != initial_content

        # Cleanup
        os.remove(test_file)

    # Appends content to existing file when using append mode
    def test_appends_to_existing_content(self):
        # Arrange
        test_file = "test_append_existing.txt"
        initial_content = "First line\n"
        second_content = "Second line\n"
        third_content = "Third line"

        # Create file with initial content
        with open(test_file, "w", encoding="utf-8") as file:
            file.write(initial_content)

        # Act - append twice
        write_string_2file(test_file, second_content, mode="a")
        write_string_2file(test_file, third_content, mode="a")

        # Assert
        with open(test_file, "r", encoding="utf-8") as file:
            content = file.read()
        assert content == initial_content + second_content + third_content

        # Cleanup
        os.remove(test_file)

    # Handling empty string as filetext
    def test_write_empty_string(self):
        # Arrange
        test_file = "test_empty.txt"
        empty_content = ""

        # Act
        write_string_2file(test_file, empty_content)

        # Assert
        assert os.path.exists(test_file)
        with open(test_file, "r", encoding="utf-8") as file:
            content = file.read()
        assert content == empty_content
        assert len(content) == 0

        # Cleanup
        os.remove(test_file)

    # Handling very large strings
    def test_write_large_string(self):
        # Arrange
        test_file = "test_large.txt"
        large_content = "A" * 1000000  # 1MB of data

        # Act
        write_string_2file(test_file, large_content)

        # Assert
        with open(test_file, "r", encoding="utf-8") as file:
            content = file.read()
        assert content == large_content
        assert len(content) == 1000000

        # Cleanup
        os.remove(test_file)

    # Handling filepath with directories that don't exist
    def test_filepath_with_nonexistent_directories(self):
        # Arrange
        test_dir = "nonexistent_dir"
        test_file = os.path.join(test_dir, "test_file.txt")
        test_content = "Content in nested file"

        # Ensure directory doesn't exist
        import shutil

        if os.path.exists(test_dir):
            shutil.rmtree(test_dir)

        # Act & Assert
        with pytest.raises(FileNotFoundError):
            write_string_2file(test_file, test_content)

        # Cleanup
        if os.path.exists(test_dir):
            shutil.rmtree(test_dir)

    # Handling file permission issues
    def test_file_permission_issues(self):
        # Skip on Windows as permission handling is different
        if os.name == "nt":
            pytest.skip("Skipping permission test on Windows")

        # Arrange
        test_file = "test_permission.txt"
        test_content = "Test content"

        # Create file and remove write permissions
        with open(test_file, "w", encoding="utf-8") as file:
            file.write("Initial content")
        os.chmod(test_file, 0o444)  # Read-only

        # Act & Assert
        with pytest.raises(PermissionError):
            write_string_2file(test_file, test_content)

        # Cleanup - restore permissions to delete
        os.chmod(test_file, 0o666)
        os.remove(test_file)
