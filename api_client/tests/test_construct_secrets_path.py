# Generated by Qodo Gen
# from api_client.helpers.config import construct_secrets_path
import os
import sys

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "../")))

import pytest

from api_client.helpers.config import construct_secrets_path


class TestConstructSecretsPath:

    # Returns correct path when secrets file exists
    def test_returns_correct_path_when_file_exists(self, mocker):
        # Arrange
        mock_getcwd = mocker.patch("os.getcwd", return_value="/root")
        mock_isfile = mocker.patch("os.path.isfile", return_value=True)
        secret_filename = ".env"
        expected_path = "/root/config/.env"

        # Act
        result = construct_secrets_path(secret_filename)

        # Assert
        assert result == expected_path
        mock_isfile.assert_called_once_with(expected_path)

    # Constructs path using current working directory and config folder
    def test_constructs_path_using_cwd_and_config_folder(self, mocker):
        # Arrange
        mock_getcwd = mocker.patch("os.getcwd", return_value="/custom/path")
        mock_isfile = mocker.patch("os.path.isfile", return_value=True)
        secret_filename = "secrets.env"
        expected_path = "/custom/path/config/secrets.env"

        # Act
        result = construct_secrets_path(secret_filename)

        # Assert
        assert result == expected_path
        mock_getcwd.assert_called_once()

    # Properly formats the path with the provided filename
    def test_formats_path_with_provided_filename(self, mocker):
        # Arrange
        mocker.patch("os.getcwd", return_value="/root")
        mocker.patch("os.path.isfile", return_value=True)
        secret_filename = "test_secrets.json"
        expected_path = "/root/config/test_secrets.json"

        # Act
        result = construct_secrets_path(secret_filename)

        # Assert
        assert result == expected_path
        assert "test_secrets.json" in result

    # Handles relative paths correctly
    def test_handles_relative_paths_correctly(self, mocker):
        # Arrange
        mocker.patch("os.getcwd", return_value=".")
        mocker.patch("os.path.isfile", return_value=True)
        secret_filename = "secrets.env"
        expected_path = "./config/secrets.env"

        # Act
        result = construct_secrets_path(secret_filename)

        # Assert
        assert result == expected_path

    # Works with different filenames
    def test_works_with_different_filenames(self, mocker):
        # Arrange
        mocker.patch("os.getcwd", return_value="/root")
        mocker.patch("os.path.isfile", return_value=True)
        filenames = [".env", "secrets.json", "config.yaml", "credentials.txt"]

        for filename in filenames:
            # Act
            result = construct_secrets_path(filename)

            # Assert
            assert result == f"/root/config/{filename}"

    # Exits with code 1 when secrets file does not exist
    def test_exits_when_secrets_file_does_not_exist(self, mocker):
        # Arrange
        mocker.patch("os.getcwd", return_value="/root")
        mocker.patch("os.path.isfile", return_value=False)
        mock_print = mocker.patch("api_client.helpers.config.print")
        mock_exit = mocker.patch("sys.exit")
        secret_filename = ".env"
        expected_path = "/root/config/.env"

        # Act
        construct_secrets_path(secret_filename)

        # Assert
        mock_print.assert_called_once_with(
            f"No secret file found at dotenv_path: {expected_path}"
        )
        mock_exit.assert_called_once_with(1)

    # Handles special characters in filename
    def test_handles_special_characters_in_filename(self, mocker):
        # Arrange
        mocker.patch("os.getcwd", return_value="/root")
        mocker.patch("os.path.isfile", return_value=True)
        special_filenames = [
            "file-with-dashes.env",
            "file_with_underscores.env",
            "file.with.dots.env",
            "file@with#special$chars.env",
        ]

        for filename in special_filenames:
            # Act
            result = construct_secrets_path(filename)

            # Assert
            assert result == f"/root/config/{filename}"

    # Handles empty string as filename
    def test_handles_empty_string_as_filename(self, mocker):
        # Arrange
        mocker.patch("os.getcwd", return_value="/root")
        mocker.patch("os.path.isfile", return_value=False)
        mock_print = mocker.patch("api_client.helpers.config.print")
        mock_exit = mocker.patch("sys.exit")
        secret_filename = ""
        expected_path = "/root/config/"

        # Act
        construct_secrets_path(secret_filename)

        # Assert
        mock_print.assert_called_once_with(
            f"No secret file found at dotenv_path: {expected_path}"
        )
        mock_exit.assert_called_once_with(1)

    # Handles very long filenames
    def test_handles_very_long_filenames(self, mocker):
        # Arrange
        mocker.patch("os.getcwd", return_value="/root")
        mocker.patch("os.path.isfile", return_value=True)
        long_filename = "a" * 200 + ".env"  # 200 'a's followed by .env
        expected_path = f"/root/config/{long_filename}"

        # Act
        result = construct_secrets_path(long_filename)

        # Assert
        assert result == expected_path
        assert len(result) > 200  # Ensure the path is indeed long

    # Handles paths with spaces
    def test_handles_paths_with_spaces(self, mocker):
        # Arrange
        mocker.patch("os.getcwd", return_value="/path with spaces")
        mocker.patch("os.path.isfile", return_value=True)
        filename_with_spaces = "secret file.env"
        expected_path = "/path with spaces/config/secret file.env"

        # Act
        result = construct_secrets_path(filename_with_spaces)

        # Assert
        assert result == expected_path
        assert " " in result  # Ensure spaces are preserved
